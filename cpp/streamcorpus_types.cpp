/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "streamcorpus_types.h"

#include <algorithm>

namespace streamcorpus {

int _kOffsetTypeValues[] = {
  OffsetType::LINES,
  OffsetType::BYTES,
  OffsetType::CHARS
};
const char* _kOffsetTypeNames[] = {
  "LINES",
  "BYTES",
  "CHARS"
};
const std::map<int, const char*> _OffsetType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kOffsetTypeValues, _kOffsetTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEntityTypeValues[] = {
  EntityType::PER,
  EntityType::ORG,
  EntityType::LOC,
  EntityType::TIME,
  EntityType::DATE,
  EntityType::MONEY,
  EntityType::PERCENT,
  EntityType::MISC,
  EntityType::GPE,
  EntityType::FAC,
  EntityType::VEH,
  EntityType::WEA,
  EntityType::phone,
  EntityType::email,
  EntityType::URL
};
const char* _kEntityTypeNames[] = {
  "PER",
  "ORG",
  "LOC",
  "TIME",
  "DATE",
  "MONEY",
  "PERCENT",
  "MISC",
  "GPE",
  "FAC",
  "VEH",
  "WEA",
  "phone",
  "email",
  "URL"
};
const std::map<int, const char*> _EntityType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(15, _kEntityTypeValues, _kEntityTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMentionTypeValues[] = {
  MentionType::NAME,
  MentionType::PRO,
  MentionType::NOM
};
const char* _kMentionTypeNames[] = {
  "NAME",
  "PRO",
  "NOM"
};
const std::map<int, const char*> _MentionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMentionTypeValues, _kMentionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGenderValues[] = {
  Gender::FEMALE,
  Gender::MALE
};
const char* _kGenderNames[] = {
  "FEMALE",
  "MALE"
};
const std::map<int, const char*> _Gender_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGenderValues, _kGenderNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kAttributeTypeValues[] = {
  AttributeType::PER_AGE,
  AttributeType::PER_GENDER
};
const char* _kAttributeTypeNames[] = {
  "PER_AGE",
  "PER_GENDER"
};
const std::map<int, const char*> _AttributeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kAttributeTypeValues, _kAttributeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRelationTypeValues[] = {
  RelationType::PHYS_Located,
  RelationType::PHYS_Near,
  RelationType::PARTWHOLE_Geographical,
  RelationType::PARTWHOLE_Subsidiary,
  RelationType::PARTWHOLE_Artifact,
  RelationType::PERSOC_Business,
  RelationType::PERSOC_Family,
  RelationType::PERSOC_LastingPersonal,
  RelationType::ORGAFF_Employment,
  RelationType::ORGAFF_Ownership,
  RelationType::ORGAFF_Founder,
  RelationType::ORGAFF_StudentAlum,
  RelationType::ORGAFF_SportsAffiliation,
  RelationType::ORGAFF_InvestorShareholder,
  RelationType::ORGAFF_Membership,
  RelationType::ART_UserOwnerInventorManufacturer,
  RelationType::GENAFF_CitizenResidentReligionEthnicity,
  RelationType::GENAFF_OrgLocation,
  RelationType::Business_DeclareBankruptcy,
  RelationType::Business_EndOrg,
  RelationType::Business_MergeOrg,
  RelationType::Business_StartOrg,
  RelationType::Conflict_Attack,
  RelationType::Conflict_Demonstrate,
  RelationType::Contact_PhoneWrite,
  RelationType::Contact_Meet,
  RelationType::Justice_Acquit,
  RelationType::Justice_Appeal,
  RelationType::Justice_ArrestJail,
  RelationType::Justice_ChargeIndict,
  RelationType::Justice_Convict,
  RelationType::Justice_Execute,
  RelationType::Justice_Extradite,
  RelationType::Justice_Fine,
  RelationType::Justice_Pardon,
  RelationType::Justice_ReleaseParole,
  RelationType::Justice_Sentence,
  RelationType::Justice_Sue,
  RelationType::Justice_TrialHearing,
  RelationType::Life_BeBorn,
  RelationType::Life_Die,
  RelationType::Life_Divorce,
  RelationType::Life_Injure,
  RelationType::Life_Marry,
  RelationType::Movement_Transport,
  RelationType::Personnel_Elect,
  RelationType::Personnel_EndPosition,
  RelationType::Personnel_Nominate,
  RelationType::Personnel_StartPosition,
  RelationType::Transaction_TransferMoney,
  RelationType::Transaction_TransferOwnership
};
const char* _kRelationTypeNames[] = {
  "PHYS_Located",
  "PHYS_Near",
  "PARTWHOLE_Geographical",
  "PARTWHOLE_Subsidiary",
  "PARTWHOLE_Artifact",
  "PERSOC_Business",
  "PERSOC_Family",
  "PERSOC_LastingPersonal",
  "ORGAFF_Employment",
  "ORGAFF_Ownership",
  "ORGAFF_Founder",
  "ORGAFF_StudentAlum",
  "ORGAFF_SportsAffiliation",
  "ORGAFF_InvestorShareholder",
  "ORGAFF_Membership",
  "ART_UserOwnerInventorManufacturer",
  "GENAFF_CitizenResidentReligionEthnicity",
  "GENAFF_OrgLocation",
  "Business_DeclareBankruptcy",
  "Business_EndOrg",
  "Business_MergeOrg",
  "Business_StartOrg",
  "Conflict_Attack",
  "Conflict_Demonstrate",
  "Contact_PhoneWrite",
  "Contact_Meet",
  "Justice_Acquit",
  "Justice_Appeal",
  "Justice_ArrestJail",
  "Justice_ChargeIndict",
  "Justice_Convict",
  "Justice_Execute",
  "Justice_Extradite",
  "Justice_Fine",
  "Justice_Pardon",
  "Justice_ReleaseParole",
  "Justice_Sentence",
  "Justice_Sue",
  "Justice_TrialHearing",
  "Life_BeBorn",
  "Life_Die",
  "Life_Divorce",
  "Life_Injure",
  "Life_Marry",
  "Movement_Transport",
  "Personnel_Elect",
  "Personnel_EndPosition",
  "Personnel_Nominate",
  "Personnel_StartPosition",
  "Transaction_TransferMoney",
  "Transaction_TransferOwnership"
};
const std::map<int, const char*> _RelationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(51, _kRelationTypeValues, _kRelationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kVersionsValues[] = {
  Versions::v0_2_0,
  Versions::v0_3_0
};
const char* _kVersionsNames[] = {
  "v0_2_0",
  "v0_3_0"
};
const std::map<int, const char*> _Versions_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kVersionsValues, _kVersionsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* StreamTime::ascii_fingerprint = "DD2684E5F49042C4C07B5348ECFFFD06";
const uint8_t StreamTime::binary_fingerprint[16] = {0xDD,0x26,0x84,0xE5,0xF4,0x90,0x42,0xC4,0xC0,0x7B,0x53,0x48,0xEC,0xFF,0xFD,0x06};

uint32_t StreamTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->epoch_ticks);
          this->__isset.epoch_ticks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zulu_timestamp);
          this->__isset.zulu_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StreamTime");

  xfer += oprot->writeFieldBegin("epoch_ticks", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->epoch_ticks);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zulu_timestamp", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->zulu_timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamTime &a, StreamTime &b) {
  using ::std::swap;
  swap(a.epoch_ticks, b.epoch_ticks);
  swap(a.zulu_timestamp, b.zulu_timestamp);
  swap(a.__isset, b.__isset);
}

const char* Annotator::ascii_fingerprint = "8D64F3DD69187433CDFC330482190EEE";
const uint8_t Annotator::binary_fingerprint[16] = {0x8D,0x64,0xF3,0xDD,0x69,0x18,0x74,0x33,0xCD,0xFC,0x33,0x04,0x82,0x19,0x0E,0xEE};

uint32_t Annotator::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->annotator_id);
          this->__isset.annotator_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotation_time.read(iprot);
          this->__isset.annotation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Annotator::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Annotator");

  xfer += oprot->writeFieldBegin("annotator_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->annotator_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.annotation_time) {
    xfer += oprot->writeFieldBegin("annotation_time", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->annotation_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Annotator &a, Annotator &b) {
  using ::std::swap;
  swap(a.annotator_id, b.annotator_id);
  swap(a.annotation_time, b.annotation_time);
  swap(a.__isset, b.__isset);
}

const char* Offset::ascii_fingerprint = "A20D4C3BA289AF4627C9FDEC29A1B027";
const uint8_t Offset::binary_fingerprint[16] = {0xA2,0x0D,0x4C,0x3B,0xA2,0x89,0xAF,0x46,0x27,0xC9,0xFD,0xEC,0x29,0xA1,0xB0,0x27};

uint32_t Offset::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (OffsetType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xpath);
          this->__isset.xpath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content_form);
          this->__isset.content_form = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Offset::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Offset");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->length);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.xpath) {
    xfer += oprot->writeFieldBegin("xpath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->xpath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.content_form) {
    xfer += oprot->writeFieldBegin("content_form", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->content_form);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Offset &a, Offset &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.first, b.first);
  swap(a.length, b.length);
  swap(a.xpath, b.xpath);
  swap(a.content_form, b.content_form);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Target::ascii_fingerprint = "8F380763C4E93CCC138A5250BA588978";
const uint8_t Target::binary_fingerprint[16] = {0x8F,0x38,0x07,0x63,0xC4,0xE9,0x3C,0xCC,0x13,0x8A,0x52,0x50,0xBA,0x58,0x89,0x78};

uint32_t Target::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_id);
          this->__isset.target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->kb_id);
          this->__isset.kb_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kb_snapshot_time.read(iprot);
          this->__isset.kb_snapshot_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Target::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Target");

  xfer += oprot->writeFieldBegin("target_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->target_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.kb_id) {
    xfer += oprot->writeFieldBegin("kb_id", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->kb_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kb_snapshot_time) {
    xfer += oprot->writeFieldBegin("kb_snapshot_time", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->kb_snapshot_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Target &a, Target &b) {
  using ::std::swap;
  swap(a.target_id, b.target_id);
  swap(a.kb_id, b.kb_id);
  swap(a.kb_snapshot_time, b.kb_snapshot_time);
  swap(a.__isset, b.__isset);
}

const char* Label::ascii_fingerprint = "38E221E7C84EBA053C116F99AB780CD4";
const uint8_t Label::binary_fingerprint[16] = {0x38,0xE2,0x21,0xE7,0xC8,0x4E,0xBA,0x05,0x3C,0x11,0x6F,0x99,0xAB,0x78,0x0C,0xD4};

uint32_t Label::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              OffsetType::type _key6;
              int32_t ecast8;
              xfer += iprot->readI32(ecast8);
              _key6 = (OffsetType::type)ecast8;
              Offset& _val7 = this->offsets[_key6];
              xfer += _val7.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->positive);
          this->__isset.positive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Label::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Label");

  xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->annotator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offsets) {
    xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->offsets.size()));
      std::map<OffsetType::type, Offset> ::const_iterator _iter9;
      for (_iter9 = this->offsets.begin(); _iter9 != this->offsets.end(); ++_iter9)
      {
        xfer += oprot->writeI32((int32_t)_iter9->first);
        xfer += _iter9->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.positive) {
    xfer += oprot->writeFieldBegin("positive", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->positive);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Label &a, Label &b) {
  using ::std::swap;
  swap(a.annotator, b.annotator);
  swap(a.target, b.target);
  swap(a.offsets, b.offsets);
  swap(a.positive, b.positive);
  swap(a.__isset, b.__isset);
}

const char* Attribute::ascii_fingerprint = "CD102D355AA4CEE7E2FEA15A78CFC35C";
const uint8_t Attribute::binary_fingerprint[16] = {0xCD,0x10,0x2D,0x35,0x5A,0xA4,0xCE,0xE7,0xE2,0xFE,0xA1,0x5A,0x78,0xCF,0xC3,0x5C};

uint32_t Attribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->attribute_type = (AttributeType::type)ecast10;
          this->__isset.attribute_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->evidence);
          this->__isset.evidence = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_id);
          this->__isset.sentence_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mention_id);
          this->__isset.mention_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Attribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Attribute");

  if (this->__isset.attribute_type) {
    xfer += oprot->writeFieldBegin("attribute_type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->attribute_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.evidence) {
    xfer += oprot->writeFieldBegin("evidence", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->evidence);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_id) {
    xfer += oprot->writeFieldBegin("sentence_id", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sentence_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id) {
    xfer += oprot->writeFieldBegin("mention_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->mention_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Attribute &a, Attribute &b) {
  using ::std::swap;
  swap(a.attribute_type, b.attribute_type);
  swap(a.evidence, b.evidence);
  swap(a.value, b.value);
  swap(a.sentence_id, b.sentence_id);
  swap(a.mention_id, b.mention_id);
  swap(a.__isset, b.__isset);
}

const char* Token::ascii_fingerprint = "E162B5D44385C82A09F40ED4849A62F3";
const uint8_t Token::binary_fingerprint[16] = {0xE1,0x62,0xB5,0xD4,0x43,0x85,0xC8,0x2A,0x09,0xF4,0x0E,0xD4,0x84,0x9A,0x62,0xF3};

uint32_t Token::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->token_num);
          this->__isset.token_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _ktype12;
            ::apache::thrift::protocol::TType _vtype13;
            xfer += iprot->readMapBegin(_ktype12, _vtype13, _size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              OffsetType::type _key16;
              int32_t ecast18;
              xfer += iprot->readI32(ecast18);
              _key16 = (OffsetType::type)ecast18;
              Offset& _val17 = this->offsets[_key16];
              xfer += _val17.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_pos);
          this->__isset.sentence_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lemma);
          this->__isset.lemma = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->entity_type = (EntityType::type)ecast19;
          this->__isset.entity_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mention_id);
          this->__isset.mention_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->equiv_id);
          this->__isset.equiv_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent_id);
          this->__isset.parent_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dependency_path);
          this->__isset.dependency_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _ktype21;
            ::apache::thrift::protocol::TType _vtype22;
            xfer += iprot->readMapBegin(_ktype21, _vtype22, _size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              AnnotatorID _key25;
              xfer += iprot->readString(_key25);
              std::vector<Label> & _val26 = this->labels[_key25];
              {
                _val26.clear();
                uint32_t _size27;
                ::apache::thrift::protocol::TType _etype30;
                xfer += iprot->readListBegin(_etype30, _size27);
                _val26.resize(_size27);
                uint32_t _i31;
                for (_i31 = 0; _i31 < _size27; ++_i31)
                {
                  xfer += _val26[_i31].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast32;
          xfer += iprot->readI32(ecast32);
          this->mention_type = (MentionType::type)ecast32;
          this->__isset.mention_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Token::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Token");

  xfer += oprot->writeFieldBegin("token_num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->token_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->token);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offsets) {
    xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->offsets.size()));
      std::map<OffsetType::type, Offset> ::const_iterator _iter33;
      for (_iter33 = this->offsets.begin(); _iter33 != this->offsets.end(); ++_iter33)
      {
        xfer += oprot->writeI32((int32_t)_iter33->first);
        xfer += _iter33->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_pos) {
    xfer += oprot->writeFieldBegin("sentence_pos", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sentence_pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lemma) {
    xfer += oprot->writeFieldBegin("lemma", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->lemma);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.entity_type) {
    xfer += oprot->writeFieldBegin("entity_type", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->entity_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id) {
    xfer += oprot->writeFieldBegin("mention_id", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->mention_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.equiv_id) {
    xfer += oprot->writeFieldBegin("equiv_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->equiv_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent_id) {
    xfer += oprot->writeFieldBegin("parent_id", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->parent_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dependency_path) {
    xfer += oprot->writeFieldBegin("dependency_path", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->dependency_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter34;
      for (_iter34 = this->labels.begin(); _iter34 != this->labels.end(); ++_iter34)
      {
        xfer += oprot->writeString(_iter34->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter34->second.size()));
          std::vector<Label> ::const_iterator _iter35;
          for (_iter35 = _iter34->second.begin(); _iter35 != _iter34->second.end(); ++_iter35)
          {
            xfer += (*_iter35).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_type) {
    xfer += oprot->writeFieldBegin("mention_type", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32((int32_t)this->mention_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Token &a, Token &b) {
  using ::std::swap;
  swap(a.token_num, b.token_num);
  swap(a.token, b.token);
  swap(a.offsets, b.offsets);
  swap(a.sentence_pos, b.sentence_pos);
  swap(a.lemma, b.lemma);
  swap(a.pos, b.pos);
  swap(a.entity_type, b.entity_type);
  swap(a.mention_id, b.mention_id);
  swap(a.equiv_id, b.equiv_id);
  swap(a.parent_id, b.parent_id);
  swap(a.dependency_path, b.dependency_path);
  swap(a.labels, b.labels);
  swap(a.mention_type, b.mention_type);
  swap(a.__isset, b.__isset);
}

const char* Sentence::ascii_fingerprint = "0BD494595242BE983E094A40DF42C413";
const uint8_t Sentence::binary_fingerprint[16] = {0x0B,0xD4,0x94,0x59,0x52,0x42,0xBE,0x98,0x3E,0x09,0x4A,0x40,0xDF,0x42,0xC4,0x13};

uint32_t Sentence::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tokens.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->tokens.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->tokens[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tokens = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _ktype42;
            ::apache::thrift::protocol::TType _vtype43;
            xfer += iprot->readMapBegin(_ktype42, _vtype43, _size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              AnnotatorID _key46;
              xfer += iprot->readString(_key46);
              std::vector<Label> & _val47 = this->labels[_key46];
              {
                _val47.clear();
                uint32_t _size48;
                ::apache::thrift::protocol::TType _etype51;
                xfer += iprot->readListBegin(_etype51, _size48);
                _val47.resize(_size48);
                uint32_t _i52;
                for (_i52 = 0; _i52 < _size48; ++_i52)
                {
                  xfer += _val47[_i52].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Sentence::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Sentence");

  xfer += oprot->writeFieldBegin("tokens", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tokens.size()));
    std::vector<Token> ::const_iterator _iter53;
    for (_iter53 = this->tokens.begin(); _iter53 != this->tokens.end(); ++_iter53)
    {
      xfer += (*_iter53).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter54;
      for (_iter54 = this->labels.begin(); _iter54 != this->labels.end(); ++_iter54)
      {
        xfer += oprot->writeString(_iter54->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter54->second.size()));
          std::vector<Label> ::const_iterator _iter55;
          for (_iter55 = _iter54->second.begin(); _iter55 != _iter54->second.end(); ++_iter55)
          {
            xfer += (*_iter55).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Sentence &a, Sentence &b) {
  using ::std::swap;
  swap(a.tokens, b.tokens);
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

const char* Tagging::ascii_fingerprint = "0A0DFB97882FDAD8FD6CF82C36CDF3B0";
const uint8_t Tagging::binary_fingerprint[16] = {0x0A,0x0D,0xFB,0x97,0x88,0x2F,0xDA,0xD8,0xFD,0x6C,0xF8,0x2C,0x36,0xCD,0xF3,0xB0};

uint32_t Tagging::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_id);
          this->__isset.tagger_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->raw_tagging);
          this->__isset.raw_tagging = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_config);
          this->__isset.tagger_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_version);
          this->__isset.tagger_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->generation_time.read(iprot);
          this->__isset.generation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Tagging::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Tagging");

  xfer += oprot->writeFieldBegin("tagger_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tagger_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_tagging", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->raw_tagging);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tagger_config) {
    xfer += oprot->writeFieldBegin("tagger_config", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tagger_config);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagger_version) {
    xfer += oprot->writeFieldBegin("tagger_version", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tagger_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generation_time) {
    xfer += oprot->writeFieldBegin("generation_time", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->generation_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Tagging &a, Tagging &b) {
  using ::std::swap;
  swap(a.tagger_id, b.tagger_id);
  swap(a.raw_tagging, b.raw_tagging);
  swap(a.tagger_config, b.tagger_config);
  swap(a.tagger_version, b.tagger_version);
  swap(a.generation_time, b.generation_time);
  swap(a.__isset, b.__isset);
}

const char* Relation::ascii_fingerprint = "50CD5AB579623D1F31762CDE35F209CF";
const uint8_t Relation::binary_fingerprint[16] = {0x50,0xCD,0x5A,0xB5,0x79,0x62,0x3D,0x1F,0x31,0x76,0x2C,0xDE,0x35,0xF2,0x09,0xCF};

uint32_t Relation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast56;
          xfer += iprot->readI32(ecast56);
          this->relation_type = (RelationType::type)ecast56;
          this->__isset.relation_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_id_1);
          this->__isset.sentence_id_1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mention_id_1);
          this->__isset.mention_id_1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_id_2);
          this->__isset.sentence_id_2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mention_id_2);
          this->__isset.mention_id_2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Relation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Relation");

  if (this->__isset.relation_type) {
    xfer += oprot->writeFieldBegin("relation_type", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->relation_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_id_1) {
    xfer += oprot->writeFieldBegin("sentence_id_1", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->sentence_id_1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id_1) {
    xfer += oprot->writeFieldBegin("mention_id_1", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->mention_id_1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_id_2) {
    xfer += oprot->writeFieldBegin("sentence_id_2", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sentence_id_2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id_2) {
    xfer += oprot->writeFieldBegin("mention_id_2", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->mention_id_2);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Relation &a, Relation &b) {
  using ::std::swap;
  swap(a.relation_type, b.relation_type);
  swap(a.sentence_id_1, b.sentence_id_1);
  swap(a.mention_id_1, b.mention_id_1);
  swap(a.sentence_id_2, b.sentence_id_2);
  swap(a.mention_id_2, b.mention_id_2);
  swap(a.__isset, b.__isset);
}

const char* Language::ascii_fingerprint = "5B708A954C550ECA9C1A49D3C5CAFAB9";
const uint8_t Language::binary_fingerprint[16] = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

uint32_t Language::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Language::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Language");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->code);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Language &a, Language &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

const char* ContentItem::ascii_fingerprint = "124FFE6662D2E2FCFEEB3A63A2058727";
const uint8_t ContentItem::binary_fingerprint[16] = {0x12,0x4F,0xFE,0x66,0x62,0xD2,0xE2,0xFC,0xFE,0xEB,0x3A,0x63,0xA2,0x05,0x87,0x27};

uint32_t ContentItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->raw);
          this->__isset.raw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encoding);
          this->__isset.encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->media_type);
          this->__isset.media_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clean_html);
          this->__isset.clean_html = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clean_visible);
          this->__isset.clean_visible = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->logs.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->logs.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += iprot->readString(this->logs[_i61]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.logs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->taggings.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _ktype63;
            ::apache::thrift::protocol::TType _vtype64;
            xfer += iprot->readMapBegin(_ktype63, _vtype64, _size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              TaggerID _key67;
              xfer += iprot->readString(_key67);
              Tagging& _val68 = this->taggings[_key67];
              xfer += _val68.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.taggings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->labels.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _ktype70;
            ::apache::thrift::protocol::TType _vtype71;
            xfer += iprot->readMapBegin(_ktype70, _vtype71, _size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              AnnotatorID _key74;
              xfer += iprot->readString(_key74);
              std::vector<Label> & _val75 = this->labels[_key74];
              {
                _val75.clear();
                uint32_t _size76;
                ::apache::thrift::protocol::TType _etype79;
                xfer += iprot->readListBegin(_etype79, _size76);
                _val75.resize(_size76);
                uint32_t _i80;
                for (_i80 = 0; _i80 < _size76; ++_i80)
                {
                  xfer += _val75[_i80].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->sentences.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _ktype82;
            ::apache::thrift::protocol::TType _vtype83;
            xfer += iprot->readMapBegin(_ktype82, _vtype83, _size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
              TaggerID _key86;
              xfer += iprot->readString(_key86);
              std::vector<Sentence> & _val87 = this->sentences[_key86];
              {
                _val87.clear();
                uint32_t _size88;
                ::apache::thrift::protocol::TType _etype91;
                xfer += iprot->readListBegin(_etype91, _size88);
                _val87.resize(_size88);
                uint32_t _i92;
                for (_i92 = 0; _i92 < _size88; ++_i92)
                {
                  xfer += _val87[_i92].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.sentences = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->sentence_blobs.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _ktype94;
            ::apache::thrift::protocol::TType _vtype95;
            xfer += iprot->readMapBegin(_ktype94, _vtype95, _size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              TaggerID _key98;
              xfer += iprot->readString(_key98);
              std::string& _val99 = this->sentence_blobs[_key98];
              xfer += iprot->readBinary(_val99);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.sentence_blobs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->language.read(iprot);
          this->__isset.language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->relations.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _ktype101;
            ::apache::thrift::protocol::TType _vtype102;
            xfer += iprot->readMapBegin(_ktype101, _vtype102, _size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              TaggerID _key105;
              xfer += iprot->readString(_key105);
              std::vector<Relation> & _val106 = this->relations[_key105];
              {
                _val106.clear();
                uint32_t _size107;
                ::apache::thrift::protocol::TType _etype110;
                xfer += iprot->readListBegin(_etype110, _size107);
                _val106.resize(_size107);
                uint32_t _i111;
                for (_i111 = 0; _i111 < _size107; ++_i111)
                {
                  xfer += _val106[_i111].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.relations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _ktype113;
            ::apache::thrift::protocol::TType _vtype114;
            xfer += iprot->readMapBegin(_ktype113, _vtype114, _size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              TaggerID _key117;
              xfer += iprot->readString(_key117);
              std::vector<Attribute> & _val118 = this->attributes[_key117];
              {
                _val118.clear();
                uint32_t _size119;
                ::apache::thrift::protocol::TType _etype122;
                xfer += iprot->readListBegin(_etype122, _size119);
                _val118.resize(_size119);
                uint32_t _i123;
                for (_i123 = 0; _i123 < _size119; ++_i123)
                {
                  xfer += _val118[_i123].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->external_ids.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              TaggerID _key129;
              xfer += iprot->readString(_key129);
              std::map<MentionID, std::string> & _val130 = this->external_ids[_key129];
              {
                _val130.clear();
                uint32_t _size131;
                ::apache::thrift::protocol::TType _ktype132;
                ::apache::thrift::protocol::TType _vtype133;
                xfer += iprot->readMapBegin(_ktype132, _vtype133, _size131);
                uint32_t _i135;
                for (_i135 = 0; _i135 < _size131; ++_i135)
                {
                  MentionID _key136;
                  xfer += iprot->readI32(_key136);
                  std::string& _val137 = _val130[_key136];
                  xfer += iprot->readString(_val137);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.external_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContentItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContentItem");

  if (this->__isset.raw) {
    xfer += oprot->writeFieldBegin("raw", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->raw);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoding) {
    xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->encoding);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.media_type) {
    xfer += oprot->writeFieldBegin("media_type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->media_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_html) {
    xfer += oprot->writeFieldBegin("clean_html", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->clean_html);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_visible) {
    xfer += oprot->writeFieldBegin("clean_visible", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->clean_visible);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logs) {
    xfer += oprot->writeFieldBegin("logs", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->logs.size()));
      std::vector<std::string> ::const_iterator _iter138;
      for (_iter138 = this->logs.begin(); _iter138 != this->logs.end(); ++_iter138)
      {
        xfer += oprot->writeString((*_iter138));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.taggings) {
    xfer += oprot->writeFieldBegin("taggings", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->taggings.size()));
      std::map<TaggerID, Tagging> ::const_iterator _iter139;
      for (_iter139 = this->taggings.begin(); _iter139 != this->taggings.end(); ++_iter139)
      {
        xfer += oprot->writeString(_iter139->first);
        xfer += _iter139->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->labels.size()));
      std::map<AnnotatorID, std::vector<Label> > ::const_iterator _iter140;
      for (_iter140 = this->labels.begin(); _iter140 != this->labels.end(); ++_iter140)
      {
        xfer += oprot->writeString(_iter140->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter140->second.size()));
          std::vector<Label> ::const_iterator _iter141;
          for (_iter141 = _iter140->second.begin(); _iter141 != _iter140->second.end(); ++_iter141)
          {
            xfer += (*_iter141).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentences) {
    xfer += oprot->writeFieldBegin("sentences", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->sentences.size()));
      std::map<TaggerID, std::vector<Sentence> > ::const_iterator _iter142;
      for (_iter142 = this->sentences.begin(); _iter142 != this->sentences.end(); ++_iter142)
      {
        xfer += oprot->writeString(_iter142->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter142->second.size()));
          std::vector<Sentence> ::const_iterator _iter143;
          for (_iter143 = _iter142->second.begin(); _iter143 != _iter142->second.end(); ++_iter143)
          {
            xfer += (*_iter143).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_blobs) {
    xfer += oprot->writeFieldBegin("sentence_blobs", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sentence_blobs.size()));
      std::map<TaggerID, std::string> ::const_iterator _iter144;
      for (_iter144 = this->sentence_blobs.begin(); _iter144 != this->sentence_blobs.end(); ++_iter144)
      {
        xfer += oprot->writeString(_iter144->first);
        xfer += oprot->writeBinary(_iter144->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.language) {
    xfer += oprot->writeFieldBegin("language", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->language.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.relations) {
    xfer += oprot->writeFieldBegin("relations", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->relations.size()));
      std::map<TaggerID, std::vector<Relation> > ::const_iterator _iter145;
      for (_iter145 = this->relations.begin(); _iter145 != this->relations.end(); ++_iter145)
      {
        xfer += oprot->writeString(_iter145->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter145->second.size()));
          std::vector<Relation> ::const_iterator _iter146;
          for (_iter146 = _iter145->second.begin(); _iter146 != _iter145->second.end(); ++_iter146)
          {
            xfer += (*_iter146).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 13);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->attributes.size()));
      std::map<TaggerID, std::vector<Attribute> > ::const_iterator _iter147;
      for (_iter147 = this->attributes.begin(); _iter147 != this->attributes.end(); ++_iter147)
      {
        xfer += oprot->writeString(_iter147->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter147->second.size()));
          std::vector<Attribute> ::const_iterator _iter148;
          for (_iter148 = _iter147->second.begin(); _iter148 != _iter147->second.end(); ++_iter148)
          {
            xfer += (*_iter148).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.external_ids) {
    xfer += oprot->writeFieldBegin("external_ids", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->external_ids.size()));
      std::map<TaggerID, std::map<MentionID, std::string> > ::const_iterator _iter149;
      for (_iter149 = this->external_ids.begin(); _iter149 != this->external_ids.end(); ++_iter149)
      {
        xfer += oprot->writeString(_iter149->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter149->second.size()));
          std::map<MentionID, std::string> ::const_iterator _iter150;
          for (_iter150 = _iter149->second.begin(); _iter150 != _iter149->second.end(); ++_iter150)
          {
            xfer += oprot->writeI32(_iter150->first);
            xfer += oprot->writeString(_iter150->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContentItem &a, ContentItem &b) {
  using ::std::swap;
  swap(a.raw, b.raw);
  swap(a.encoding, b.encoding);
  swap(a.media_type, b.media_type);
  swap(a.clean_html, b.clean_html);
  swap(a.clean_visible, b.clean_visible);
  swap(a.logs, b.logs);
  swap(a.taggings, b.taggings);
  swap(a.labels, b.labels);
  swap(a.sentences, b.sentences);
  swap(a.sentence_blobs, b.sentence_blobs);
  swap(a.language, b.language);
  swap(a.relations, b.relations);
  swap(a.attributes, b.attributes);
  swap(a.external_ids, b.external_ids);
  swap(a.__isset, b.__isset);
}

const char* Rating::ascii_fingerprint = "DCBA8CB33AD8DD99F9FD43759B321154";
const uint8_t Rating::binary_fingerprint[16] = {0xDC,0xBA,0x8C,0xB3,0x3A,0xD8,0xDD,0x99,0xF9,0xFD,0x43,0x75,0x9B,0x32,0x11,0x54};

uint32_t Rating::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->relevance);
          this->__isset.relevance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->contains_mention);
          this->__isset.contains_mention = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comments);
          this->__isset.comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mentions.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readListBegin(_etype154, _size151);
            this->mentions.resize(_size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              xfer += iprot->readString(this->mentions[_i155]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.mentions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Rating::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Rating");

  xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->annotator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.relevance) {
    xfer += oprot->writeFieldBegin("relevance", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->relevance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.contains_mention) {
    xfer += oprot->writeFieldBegin("contains_mention", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->contains_mention);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comments) {
    xfer += oprot->writeFieldBegin("comments", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->comments);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mentions) {
    xfer += oprot->writeFieldBegin("mentions", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->mentions.size()));
      std::vector<std::string> ::const_iterator _iter156;
      for (_iter156 = this->mentions.begin(); _iter156 != this->mentions.end(); ++_iter156)
      {
        xfer += oprot->writeString((*_iter156));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Rating &a, Rating &b) {
  using ::std::swap;
  swap(a.annotator, b.annotator);
  swap(a.target, b.target);
  swap(a.relevance, b.relevance);
  swap(a.contains_mention, b.contains_mention);
  swap(a.comments, b.comments);
  swap(a.mentions, b.mentions);
  swap(a.__isset, b.__isset);
}

const char* StreamItem::ascii_fingerprint = "F858834988A57CDA6EB18D2A772CC260";
const uint8_t StreamItem::binary_fingerprint[16] = {0xF8,0x58,0x83,0x49,0x88,0xA5,0x7C,0xDA,0x6E,0xB1,0x8D,0x2A,0x77,0x2C,0xC2,0x60};

uint32_t StreamItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast157;
          xfer += iprot->readI32(ecast157);
          this->version = (Versions::type)ecast157;
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc_id);
          this->__isset.doc_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abs_url);
          this->__isset.abs_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schost);
          this->__isset.schost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->original_url);
          this->__isset.original_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->source_metadata.clear();
            uint32_t _size158;
            ::apache::thrift::protocol::TType _ktype159;
            ::apache::thrift::protocol::TType _vtype160;
            xfer += iprot->readMapBegin(_ktype159, _vtype160, _size158);
            uint32_t _i162;
            for (_i162 = 0; _i162 < _size158; ++_i162)
            {
              std::string _key163;
              xfer += iprot->readString(_key163);
              SourceMetadata& _val164 = this->source_metadata[_key163];
              xfer += iprot->readBinary(_val164);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.source_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stream_id);
          this->__isset.stream_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stream_time.read(iprot);
          this->__isset.stream_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->other_content.clear();
            uint32_t _size165;
            ::apache::thrift::protocol::TType _ktype166;
            ::apache::thrift::protocol::TType _vtype167;
            xfer += iprot->readMapBegin(_ktype166, _vtype167, _size165);
            uint32_t _i169;
            for (_i169 = 0; _i169 < _size165; ++_i169)
            {
              std::string _key170;
              xfer += iprot->readString(_key170);
              ContentItem& _val171 = this->other_content[_key170];
              xfer += _val171.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.other_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ratings.clear();
            uint32_t _size172;
            ::apache::thrift::protocol::TType _ktype173;
            ::apache::thrift::protocol::TType _vtype174;
            xfer += iprot->readMapBegin(_ktype173, _vtype174, _size172);
            uint32_t _i176;
            for (_i176 = 0; _i176 < _size172; ++_i176)
            {
              AnnotatorID _key177;
              xfer += iprot->readString(_key177);
              std::vector<Rating> & _val178 = this->ratings[_key177];
              {
                _val178.clear();
                uint32_t _size179;
                ::apache::thrift::protocol::TType _etype182;
                xfer += iprot->readListBegin(_etype182, _size179);
                _val178.resize(_size179);
                uint32_t _i183;
                for (_i183 = 0; _i183 < _size179; ++_i183)
                {
                  xfer += _val178[_i183].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ratings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->external_ids.clear();
            uint32_t _size184;
            ::apache::thrift::protocol::TType _ktype185;
            ::apache::thrift::protocol::TType _vtype186;
            xfer += iprot->readMapBegin(_ktype185, _vtype186, _size184);
            uint32_t _i188;
            for (_i188 = 0; _i188 < _size184; ++_i188)
            {
              SystemID _key189;
              xfer += iprot->readString(_key189);
              std::map<DocIDorStreamID, std::string> & _val190 = this->external_ids[_key189];
              {
                _val190.clear();
                uint32_t _size191;
                ::apache::thrift::protocol::TType _ktype192;
                ::apache::thrift::protocol::TType _vtype193;
                xfer += iprot->readMapBegin(_ktype192, _vtype193, _size191);
                uint32_t _i195;
                for (_i195 = 0; _i195 < _size191; ++_i195)
                {
                  DocIDorStreamID _key196;
                  xfer += iprot->readString(_key196);
                  std::string& _val197 = _val190[_key196];
                  xfer += iprot->readString(_val197);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.external_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StreamItem");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doc_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->doc_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.abs_url) {
    xfer += oprot->writeFieldBegin("abs_url", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->abs_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schost) {
    xfer += oprot->writeFieldBegin("schost", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->schost);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_url) {
    xfer += oprot->writeFieldBegin("original_url", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->original_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->source);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->body.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source_metadata) {
    xfer += oprot->writeFieldBegin("source_metadata", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->source_metadata.size()));
      std::map<std::string, SourceMetadata> ::const_iterator _iter198;
      for (_iter198 = this->source_metadata.begin(); _iter198 != this->source_metadata.end(); ++_iter198)
      {
        xfer += oprot->writeString(_iter198->first);
        xfer += oprot->writeBinary(_iter198->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("stream_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->stream_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stream_time", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->stream_time.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_content) {
    xfer += oprot->writeFieldBegin("other_content", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_content.size()));
      std::map<std::string, ContentItem> ::const_iterator _iter199;
      for (_iter199 = this->other_content.begin(); _iter199 != this->other_content.end(); ++_iter199)
      {
        xfer += oprot->writeString(_iter199->first);
        xfer += _iter199->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ratings) {
    xfer += oprot->writeFieldBegin("ratings", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->ratings.size()));
      std::map<AnnotatorID, std::vector<Rating> > ::const_iterator _iter200;
      for (_iter200 = this->ratings.begin(); _iter200 != this->ratings.end(); ++_iter200)
      {
        xfer += oprot->writeString(_iter200->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter200->second.size()));
          std::vector<Rating> ::const_iterator _iter201;
          for (_iter201 = _iter200->second.begin(); _iter201 != _iter200->second.end(); ++_iter201)
          {
            xfer += (*_iter201).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.external_ids) {
    xfer += oprot->writeFieldBegin("external_ids", ::apache::thrift::protocol::T_MAP, 14);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->external_ids.size()));
      std::map<SystemID, std::map<DocIDorStreamID, std::string> > ::const_iterator _iter202;
      for (_iter202 = this->external_ids.begin(); _iter202 != this->external_ids.end(); ++_iter202)
      {
        xfer += oprot->writeString(_iter202->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter202->second.size()));
          std::map<DocIDorStreamID, std::string> ::const_iterator _iter203;
          for (_iter203 = _iter202->second.begin(); _iter203 != _iter202->second.end(); ++_iter203)
          {
            xfer += oprot->writeString(_iter203->first);
            xfer += oprot->writeString(_iter203->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamItem &a, StreamItem &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.doc_id, b.doc_id);
  swap(a.abs_url, b.abs_url);
  swap(a.schost, b.schost);
  swap(a.original_url, b.original_url);
  swap(a.source, b.source);
  swap(a.body, b.body);
  swap(a.source_metadata, b.source_metadata);
  swap(a.stream_id, b.stream_id);
  swap(a.stream_time, b.stream_time);
  swap(a.other_content, b.other_content);
  swap(a.ratings, b.ratings);
  swap(a.external_ids, b.external_ids);
  swap(a.__isset, b.__isset);
}

} // namespace
